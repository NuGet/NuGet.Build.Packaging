<!--
***********************************************************************************************
Microsoft.NuGet.Build.Packaging.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<UsingTask TaskName="NuGet.Build.Packaging.Tasks.AssignPackagePath" AssemblyFile="NuGet.Build.Packaging.Tasks.dll" />
	<UsingTask TaskName="NuGet.Build.Packaging.Tasks.CreatePackage" AssemblyFile="NuGet.Build.Packaging.Tasks.dll" />

	<PropertyGroup>
		<IncludeSymbols Condition=" '$(IncludeSymbols)' == '' and '$(Configuration)' == 'Debug' ">true</IncludeSymbols>
		<IsPackable Condition="'$(IsPackable)' == '' And '$(PackageId)' != ''">true</IsPackable>
		<BuildPackage Condition=" '$(BuildPackage)' == '' and '$(IsPackable)' == 'true'">true</BuildPackage>
		<!-- Directory where the .nupkg will be saved to if BuildPackage is run -->
		<PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(IntermediateOutputPath)</PackageOutputPath>
		<BuildDependsOn Condition="'$(BuildPackage)' == 'true'">
			$(BuildDependsOn);
			Pack;
		</BuildDependsOn>
		<!-- NOTE: this is the "internal" DependsOn for our implementation of the collecting target.
			 Users extend GetPackageContentsDependsOn instead. This ensures that our own dependencies will not 
			 be accidentally overriden.
		-->
		<_GetPackageContentsDependsOn>
			AssignProjectConfiguration;
			_SplitProjectReferencesByFileExistence;
			AllProjectOutputGroups;
			_CollectPackageContents;
		</_GetPackageContentsDependsOn>
	</PropertyGroup>

	<Target Name="GetPackageContents" DependsOnTargets="$(_GetPackageContentsDependsOn)" Returns="@(_PackageContent)" />

	<Target Name="_CollectPackageContents" DependsOnTargets="$(GetPackageContentsDependsOn)">
		<!-- We define these here so that potentially other targets can populate these properties before this target runs. -->
		<PropertyGroup>
			<PackageVersion Condition=" '$(PackageVersion)' == '' ">$(Version)</PackageVersion>
		</PropertyGroup>

		<!-- PackageId metadata on all PackageFile items means we can tell appart which ones came from which dependencies 
         NOTE: if PackageId is empty, we won't generate a manifest and it means the files need to be packed with the 
         current project. -->
		<ItemGroup>
			<PackageFile Include="@(BuiltProjectOutputGroupOutput -> '%(FinalOutputPath)')">
				<Kind>Lib</Kind>
			</PackageFile>

			<PackageFile Include="@(DebugSymbolsProjectOutputGroupOutput -> '%(FinalOutputPath)')"
						 Condition="'$(IncludeSymbols)' == 'true'">
				<Kind>Symbols</Kind>
			</PackageFile>

			<PackageFile Include="@(DocumentationProjectOutputGroupOutput -> '%(FinalOutputPath)')">
				<Kind>Doc</Kind>
			</PackageFile>
		</ItemGroup>

		<ItemGroup>
			<!-- Always annotate files with the declaring project target framework and package id. 
				 TODO: take into account multi-targetting. -->
			<PackageFile>
				<PackageId>$(PackageId)</PackageId>
				<TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
			</PackageFile>
		</ItemGroup>

		<AssignPackagePath Files="@(PackageFile)" Kinds="@(PackageItemKind)">
			<Output TaskParameter="AssignedFiles" ItemName="_PackageContent" />
		</AssignPackagePath>

		<ItemGroup>
			<!-- Convert PackageReferences to _PackageContent -->
			<_PackageContent Include="@(PackageReference)">
				<Kind>Dependency</Kind>
			</_PackageContent>

			<!-- Specific framework targets would turn:
				* @(ReferencePath) with ResolvedFrom={TargetFrameworkDirectory} to Kind=FrameworkReference
				  (maybe ResolvedFrom=ImplicitlyExpandDesignTimeFacades too?)
				* @(ReferencePath) are resolved otherwise (i.e. ResolvedFrom={RawFile}) to Kind=AssemblyReference
			-->
		</ItemGroup>

		<!-- If packaging the project, provide the metadata as a non-file item -->
		<ItemGroup Condition="'$(PackageId)' != ''">
			<_PackageContent Include="$(PackageId)">
				<Kind>Metadata</Kind>
				
				<!-- The rest of the metadata items don't need to repeat "Package" prefix all the time -->
				<Id>$(PackageId)</Id>
				<Version>$(PackageVersion)</Version>
				<Authors>$(Authors)</Authors>
				<Owners>$(Owners)</Owners>
				<Title>$(Title)</Title>
				<Description>$(Description)</Description>
				<Summary>$(Summary)</Summary>
				<Language>$(NeutralLanguage)</Language>
				<Copyright>$(Copyright)</Copyright>

				<RequireLicenseAcceptance>$(PackageRequireLicenseAcceptance)</RequireLicenseAcceptance>
				<LicenseUrl>$(PackageLicenseUrl)</LicenseUrl>
				<ProjectUrl>$(PackageProjectUrl)</ProjectUrl>
				<IconUrl>$(PackageIconUrl)</IconUrl>
				<Tags>$(PackageTags)</Tags>

				<ReleaseNotes>$(PackageReleaseNotes)</ReleaseNotes>
				<RepositoryUrl>$(RepositoryUrl)</RepositoryUrl>
				<RepositoryType>$(RepositoryType)</RepositoryType>
				<PackageType>$(PackageType)</PackageType>
			</_PackageContent>
		</ItemGroup>

		<ItemGroup>
			<!-- Ensure our content items have both metadata values -->
			<_PackageContent>
				<PackageId>$(PackageId)</PackageId>
				<TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
			</_PackageContent>
		</ItemGroup>

		<MSBuild Projects="@(_MSBuildProjectReferenceExistent)"
				 Targets="GetPackageContents"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
				 Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''"
				 RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedPackageContent" />
		</MSBuild>

		<!-- Always annotate package contents with the declaring project target framework and package id -->
		<ItemGroup>
			<_ReferencedPackageContent Condition="'%(_ReferencedPackageContent.PackageId)' == ''">
				<!-- We preserve whatever package id the item had -->
				<PackageId>$(PackageId)</PackageId>
				<!-- NOTE: we're always overwriting the TFM in this case since 
					 this item will end up making up the contents of this package 
					 project in its current TFM configuration. 
					 TBD: we might want to preserve it anyways and adjust later 
					 (i.e. net45 project references netstandard1.6 project)
					 TODO: take into account multi-targetting.
				-->
				<TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
			</_ReferencedPackageContent>
		</ItemGroup>

		<!-- Ensure referenced package content gets assigned a package path if it didn't provide one already.
			 This happens for project references' that don't have a PackageId, since their package path will 
			 depend on the referencing project's TFM.
		-->
		<AssignPackagePath Files="@(_ReferencedPackageContent)" Kinds="@(PackageItemKind)">
			<Output TaskParameter="AssignedFiles" ItemName="_PackageContent" />
		</AssignPackagePath>

	</Target>

	<Target Name="Pack" DependsOnTargets="GetPackageContents;$(PackDependsOn);_FilterPackageDependencyContents" Condition="'$(IsPackable)' == 'true'">
		<!-- RepositoryUrl/RepositoryType/PackageType to be added -->
		<CreatePackage Id="$(PackageId)"
					   Version="$(PackageVersion)"
					   Contents="@(_FilteredPackageContent)"
					   Authors="$(Authors)"
					   Owners="$(Owners)"
					   Title="$(Title)"
					   Description="$(Description)"
					   Summary="$(Summary)"
					   Language="$(NeutralLanguage)"
					   Copyright="$(Copyright)"
					   
					   RequireLicenseAcceptance="$(PackageRequireLicenseAcceptance)"
					   LicenseUrl="$(PackageLicenseUrl)"
					   ProjectUrl="$(PackageProjectUrl)"
					   IconUrl="$(PackageIconUrl)"
					   Tags="$(PackageTags)"

					   ReleaseNotes="$(PackageReleaseNotes)"
					   MinClientVersion="$(MinClientVersion)"
					   
					   OutputPath="$(PackageOutputPath)" />
	</Target>

	<!-- This target's purpose is to remove from _PackageContent the items that are the contents of 
		 indirect package dependencies that transitive project references build, turning those into 
		 just a Dependency item for Pack.
		 The Outputs="%(PackageId)-BATCH" groups the @(_PackageContent) into batches coming from the same 
		 package for easier processing. The '-BATCH' ensures we also process the batch without a PackageId.
	-->
	<Target Name="_FilterPackageDependencyContents" DependsOnTargets="GetPackageContents" Inputs="@(_PackageContent)" Outputs="%(PackageId)-BATCH" Returns="@(_FilteredPackageContent)">
		<ItemGroup>
			<!-- Attempt to grab a manifest for the current batch -->
			<_DependencyManifest Include="@(_PackageContent)" Condition="'%(Kind)' == 'Metadata'" />
		</ItemGroup>
		<PropertyGroup>
			<!-- Determine up-front if this batch belongs to the package being built.
				 We do this by checking for empty %(MSBuildSourceProjectFile), since 
				 that metadata is assigned for project references we execute GetPackageContents on.
			-->
			<IsSelfContent>@(_PackageContent -> AnyHaveMetadataValue("MSBuildSourceProjectFile", ""))</IsSelfContent>
			<!-- If the group has a metadata item, then it's all part of a package dependency -->
			<IsDependencyContent Condition="'$(IsSelfContent)' != 'true' And '@(_DependencyManifest)' != ''">true</IsDependencyContent>
			<!-- Grab the dependency source project in this case, to use it right after -->
			<DependencySourceProject Condition="'$(IsDependencyContent)' == 'true'">@(_DependencyManifest -> '%(MSBuildSourceProjectFile)')</DependencySourceProject>
			<!-- Lookup the dependency project in the list of referenced MSBuild projects to detect a direct dependency -->
			<IsDirectDependency Condition="'$(IsDependencyContent)' == 'true'">@(_MSBuildProjectReferenceExistent -> AnyHaveMetadataValue("FullPath", "$(DependencySourceProject)"))</IsDirectDependency>
		</PropertyGroup>

		<ItemGroup Condition="'$(IsDependencyContent)' == 'true'">
			<!-- Only keep the package dependency if it's a direct project reference. 
				 We don't need the transitive packages for pack -->
			<_FilteredPackageContent Include="@(_DependencyManifest)" Condition="'$(IsDirectDependency)' == 'true'">
				<!-- Change its kind to Dependency. It will already contain the Version metadata for further processing -->
				<Kind>Dependency</Kind>
			</_FilteredPackageContent>
		</ItemGroup>
		<ItemGroup Condition="'$(IsDependencyContent)' != 'true'">
			<!-- Otherwise, bring it all in since there is no package to depend on -->
			<_FilteredPackageContent Include="@(_PackageContent)" />
		</ItemGroup>
	</Target>

</Project>
