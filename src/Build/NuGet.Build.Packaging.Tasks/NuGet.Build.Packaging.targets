<!--
***********************************************************************************************
Microsoft.NuGet.Build.Packaging.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<UsingTask TaskName="NuGet.Build.Packaging.Tasks.AssignPackagePath" AssemblyFile="NuGet.Build.Packaging.Tasks.dll" />
	<UsingTask TaskName="NuGet.Build.Packaging.Tasks.CreatePackage" AssemblyFile="NuGet.Build.Packaging.Tasks.dll" />

	<Import Project="NuGet.Build.Packaging.props" Condition="'$(NuGetBuildPackagingPropsImported)' == ''" />

	<PropertyGroup>
		<IncludeOutputsInPackage Condition="'$(IncludeOutputsInPackage)' == ''">true</IncludeOutputsInPackage>
		<IncludeSymbolsInPackage Condition="'$(IncludeSymbolsInPackage)' == '' and '$(IncludeOutputsInPackage)' == 'true' and '$(Configuration)' == 'Debug'">true</IncludeSymbolsInPackage>
		<IncludeContentInPackage Condition="'$(IncludeContentInPackage)' == ''">true</IncludeContentInPackage>
		<IncludeFrameworkReferencesInPackage Condition="'$(IncludeFrameworkReferencesInPackage)' == ''">true</IncludeFrameworkReferencesInPackage>

		<PackageRequireLicenseAcceptance Condition="'$(PackageRequireLicenseAcceptance)' == ''">false</PackageRequireLicenseAcceptance>

		<!-- NOTE: we will always have this property in projects referencing this targets file. Can be used to detect this. -->
		<IsPackable Condition="'$(IsPackable)' == '' and '$(PackageId)' != ''">true</IsPackable>
		<IsPackable Condition="'$(IsPackable)' == '' and '$(PackageId)' == ''">false</IsPackable>

		<!-- Directory where the .nupkg will be saved to if Pack is run, used also in GetPackageTargetPath -->
		<PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(OutputPath)</PackageOutputPath>

		<BuildDependsOn Condition="'$(PackOnBuild)' == 'true' and '$(IsPackable)' == 'true'">
			$(BuildDependsOn);
			Pack;
		</BuildDependsOn>
	</PropertyGroup>

	<!--
	============================================================
					GetTargetPath

    This target is redefined from the common targets to add the 
	%(IsPackable) metadata, which is used by the GetPacakgeContents 
	target to detect project references that don't have this 
	nuget package installed (and would therefore not behave 
	properly when packed from the referencing project).
	============================================================
	-->
	<Target Name="GetTargetPath"
			DependsOnTargets="$(GetTargetPathDependsOn)"
			Returns="@(TargetPathWithTargetPlatformMonikerAndIsPackable)">
		<ItemGroup>
			<TargetPathWithTargetPlatformMonikerAndIsPackable Include="$(TargetPath)">
				<TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
				<TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
				<IsPackable>$(IsPackable)</IsPackable>
			</TargetPathWithTargetPlatformMonikerAndIsPackable>
		</ItemGroup>
	</Target>

	<!--
	============================================================
					GetPackageVersion

    This target sets the default $(PackageVersion) to $(Version) 
	if empty, and returns it. 
	
	It can be redefined to change how the package version is 
	determined.
	============================================================
	-->
	<PropertyGroup>
		<GetPackageVersionDependsOn>
			$(GetPackageVersionDependsOn);
			_SetDefaultPackageVersion
		</GetPackageVersionDependsOn>
	</PropertyGroup>
	<Target Name="GetPackageVersion" DependsOnTargets="$(GetPackageVersionDependsOn)" Returns="$(PackageVersion)" />
	<Target Name="_SetDefaultPackageVersion" Condition="'$(PackageVersion)' == ''" Returns="$(PackageVersion)">
		<PropertyGroup>
			<PackageVersion Condition=" '$(PackageVersion)' == '' ">$(Version)</PackageVersion>
		</PropertyGroup>
	</Target>

	<!--
	============================================================
					GetPackageTargetPath

    If the project builds a package (that is, it has a PackageId), 
    this target returns an item for the $(PackageTargetPath) that 
    the project builds, as well as manifest metadata included in 
    the project for the resulting package, not including its 
    contents and dependencies, which must be retrieved from the 
    GetPackageContents target instead.
   ============================================================
	-->
	<PropertyGroup>
		<GetPackageTargetPathDependsOn>
			$(GetPackageTargetPathDependsOn);
			GetPackageVersion;
			_SetDefaultPackageTargetPath;
		</GetPackageTargetPathDependsOn>
	</PropertyGroup>
	<Target Name="GetPackageTargetPath" Condition="'$(IsPackable)' == 'true'" DependsOnTargets="$(GetPackageTargetPathDependsOn)" Returns="@(PackageTargetPath)">
		<ItemGroup>
			<!-- Ensure we got a full path -->
			<PackageTargetPath Include="$([System.IO.Path]::GetFullPath('$(PackageTargetPath)'))">
				<Id>$(PackageId)</Id>
				<Version>$(PackageVersion)</Version>
				<DevelopmentDependency Condition="'$(IsDevelopmentDependency)' == 'true'">true</DevelopmentDependency>

				<Authors>$(Authors)</Authors>
				<Owners>$(Owners)</Owners>
				<Title>$(Title)</Title>
				<Description>$(Description)</Description>
				<Summary>$(Summary)</Summary>
				<Language>$(NeutralLanguage)</Language>
				<Copyright>$(Copyright)</Copyright>

				<RequireLicenseAcceptance>$(PackageRequireLicenseAcceptance)</RequireLicenseAcceptance>
				<LicenseUrl>$(PackageLicenseUrl)</LicenseUrl>
				<ProjectUrl>$(PackageProjectUrl)</ProjectUrl>
				<IconUrl>$(PackageIconUrl)</IconUrl>
				<Tags>$(PackageTags)</Tags>

				<ReleaseNotes>$(PackageReleaseNotes)</ReleaseNotes>
				<RepositoryUrl>$(RepositoryUrl)</RepositoryUrl>
				<RepositoryType>$(RepositoryType)</RepositoryType>
				<PackageTypes>$(PackageTypes)</PackageTypes>
			</PackageTargetPath>
		</ItemGroup>
	</Target>
	<Target Name="_SetDefaultPackageTargetPath" Condition="'$(IsPackable)' == 'true' and '$(PackageTargetPath)' == ''">
		<PropertyGroup>
			<PackageTargetPath Condition="'$(PackageTargetPath)' == ''">$([System.IO.Path]::Combine('$(PackageOutputPath)', '$(PackageId).$(PackageVersion).nupkg'))</PackageTargetPath>
		</PropertyGroup>
	</Target>

	<!--
    ============================================================
						PackageOutputGroup
    ============================================================
    -->
	<PropertyGroup>
		<AllProjectOutputGroupsDependsOn>
			PackageOutputGroup;
			$(AllProjectOutputGroupsDependsOn)
		</AllProjectOutputGroupsDependsOn>
		<PackageOutputGroupDependsOn>GetPackageTargetPath;$(PackageOutputGroupDependsOn)</PackageOutputGroupDependsOn>
	</PropertyGroup>
	<Target Name="PackageOutputGroup" Returns="@(PackageTargetPath)" DependsOnTargets="$(PackageOutputGroupDependsOn)" />

	<PropertyGroup>
		<!-- NOTE: these are the "internal" DependsOn for our implementation of the collecting and filtering targets.
			 Users extend GetPackageContentsDependsOn instead. This ensures that our own dependencies will not 
			 be accidentally overriden.
		-->
		<_GetPackageContentsDependsOn>
			GetAllPackageContents;
			_GetPackageContents;
		</_GetPackageContentsDependsOn>
		<!-- Only depend on ResolveReferences if we need to include framework references -->
		<_GetAllPackageContentsDependsOn Condition="'$(IncludeFrameworkReferencesInPackage)' == 'true'">
			ResolveReferences
		</_GetAllPackageContentsDependsOn>
		<_GetAllPackageContentsDependsOn>
			$(_GetAllPackageContentsDependsOn);
			GetPackageTargetPath;
			AssignProjectConfiguration;
			_SplitProjectReferencesByFileExistence;
			_SplitProjectReferencesByIsPackablePresence;
			AllProjectOutputGroups;
		</_GetAllPackageContentsDependsOn>
		<_GetAllPackageContentsDependsOn Condition="'$(IncludeOutputsInPackage)' == 'true'">
			$(_GetAllPackageContentsDependsOn)
			_CollectMissingIsPackableProjectReferencesOutputs;
		</_GetAllPackageContentsDependsOn>
		<_GetAllPackageContentsDependsOn>
			$(_GetAllPackageContentsDependsOn)
			_CollectAllPackageContents;			
		</_GetAllPackageContentsDependsOn>
	</PropertyGroup>

	<!--
	============================================================
					GetPackageContents

    Returns the "virtual package" for the current project, containing 
	all items that would end up in a .nupkg if the project were 
	to be packed. 
	
	If the project has NuGet metadata to generate a .nupkg, a metadata 
	item containing the manifest information will also be returned, as 
	
		Identity=$(PackageId)
		   %(Kind)=Metadata
		   ... all manifest values as metadata items ...
	
	All items returned from this target contain a %(PackageId) metadata 
	with the project's $(PackageId), if any.
	============================================================
	-->
	<Target Name="GetPackageContents" DependsOnTargets="$(_GetPackageContentsDependsOn)" Returns="@(_PackageContent)" />

	<!-- This target's purpose is to remove from _PackageContent the items that are the contents of 
		 indirect package dependencies that transitive project references build, turning those into 
		 just a Dependency item for Pack.
		 The Outputs="%(PackageId)-BATCH" groups the @(_PackageContent) into batches coming from the same 
		 package for easier processing. The '-BATCH' ensures we also process the batch without a PackageId.
	-->
	<Target Name="_GetPackageContents"
			DependsOnTargets="GetAllPackageContents"
			Inputs="@(_AllPackageContent)"
			Outputs="%(PackageId)-BATCH"
			Returns="@(_PackageContent)">
		<ItemGroup>
			<!-- Attempt to grab a manifest for the current batch -->
			<_DependencyManifest Include="@(_AllPackageContent)" Condition="'%(Kind)' == 'Metadata'" />
		</ItemGroup>
		<PropertyGroup>
			<!-- Determine up-front if this batch belongs to the package being built.
				 We do this by checking for empty %(MSBuildSourceProjectFile), since 
				 that metadata is assigned for project references we execute GetPackageContents on.
			-->
			<IsSelfContent>@(_AllPackageContent -> AnyHaveMetadataValue("MSBuildSourceProjectFile", ""))</IsSelfContent>
			<!-- If the group has a metadata item, then it's all part of a package dependency -->
			<IsDependencyContent Condition="'$(IsSelfContent)' != 'true' and '@(_DependencyManifest)' != ''">true</IsDependencyContent>
			<!-- Grab the dependency source project in this case, to use it right after -->
			<DependencySourceProject Condition="'$(IsDependencyContent)' == 'true'">@(_DependencyManifest -> '%(MSBuildSourceProjectFile)')</DependencySourceProject>
			<!-- Lookup the dependency project in the list of referenced MSBuild projects to detect a direct dependency -->
			<IsDirectDependency Condition="'$(IsDependencyContent)' == 'true'">@(_MSBuildProjectReferenceExistent -> AnyHaveMetadataValue("FullPath", "$(DependencySourceProject)"))</IsDirectDependency>
		</PropertyGroup>

		<ItemGroup Condition="'$(IsDependencyContent)' == 'true'">
			<!-- Only keep the package dependency if it's a direct project reference. 
				 We don't need the transitive packages for pack -->
			<_PackageContent Include="@(_DependencyManifest)" Condition="'$(IsDirectDependency)' == 'true'">
				<!-- Change its kind to Dependency. It will already contain the Version metadata for further processing -->
				<Kind>Dependency</Kind>
			</_PackageContent>
		</ItemGroup>
		<ItemGroup Condition="'$(IsDependencyContent)' != 'true'">
			<!-- Otherwise, bring it all in since there is no package to depend on -->
			<_PackageContent Include="@(_AllPackageContent)" />
		</ItemGroup>
	</Target>

	<Target Name="GetAllPackageContents" DependsOnTargets="$(_GetAllPackageContentsDependsOn)" Returns="@(_AllPackageContent)" />

	<!-- This target separates project references that have the packaging targets from those that don't -->
	<Target Name="_SplitProjectReferencesByIsPackablePresence" 
			Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''"
			Inputs="@(_MSBuildProjectReferenceExistent)"
			Outputs="%(_MSBuildProjectReferenceExistent.Identity)-BATCH">
		<MSBuild Projects="@(_MSBuildProjectReferenceExistent)"
					 Targets="GetTargetPath"
					 BuildInParallel="$(BuildInParallel)"
					 Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
					 RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectTargetPath" />
		</MSBuild>

		<PropertyGroup>
			<_HasIsPackable Condition="'%(_ReferencedProjectTargetPath.IsPackable)' != ''">true</_HasIsPackable>
		</PropertyGroup>
	
		<ItemGroup>
			<_NoIsPackableProject Include="@(_MSBuildProjectReferenceExistent)" Condition="'$(_HasIsPackable)' != 'true'" />
			<_IsPackableProject Include="@(_MSBuildProjectReferenceExistent)" Condition="'$(_HasIsPackable)' == 'true'" />
		</ItemGroup>

	</Target>
	
	<!-- Includes primary output and dependencies for non-nugetized projects -->
	<Target Name="_CollectMissingIsPackableProjectReferencesOutputs" Condition="'@(_NoIsPackableProject)' != ''">
		<Warning Text="Some project references do not have the 'NuGet.Build.Packaging' installed. Only primary output will be packaged.
Please install the 'NuGet.Build.Packaging' package in the following projects to ensure proper packaging of all artifacts: @(_NoIsPackableProject)"
				 Code="NG1001" />
	
		<!-- Main project and dependencies built output -->
		<MSBuild Projects="@(_NoIsPackableProject)"
				 Targets="BuiltProjectOutputGroup"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectBuiltOutput" />
		</MSBuild>

		<ItemGroup>
			<PackageFile Include="@(_ReferencedProjectBuiltOutput -> '%(FinalOutputPath)')">
				<Kind>Lib</Kind>
			</PackageFile>
		</ItemGroup>
		
		<MSBuild Projects="@(_NoIsPackableProject)"
				 Targets="BuiltProjectOutputGroupDependencies"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectOutputDependency" />
		</MSBuild>

		<ItemGroup>
			<!-- NOTE: this default heuristics does not include assemblies referenced from nuget v3 packages which look like the following:
					BuiltProjectOutputGroupDependency: %UserProfile%\.nuget\packages\Newtonsoft.Json\6.0.4\lib\net45\Newtonsoft.Json.dll
						CopyLocal=false
						NuGetIsFrameworkReference=false
						NuGetPackageId=Newtonsoft.Json
						NuGetPackageVersion=6.0.4
						NuGetSourceType=Package
						ResolvedFrom={RawFileName}
						
				Since the dependencies include the actual closure of all transitive nuget package dependencies (from its 
				lock.json or packages.config), we can't rely on these to provide the top-level dependencies we actually 
				need either.
			-->
			<PackageFile Include="@(_ReferencedProjectOutputDependency -> '%(FullPath)')" 
						 Condition="'%(_ReferencedProjectOutputDependency.CopyLocal)' == 'true' and
						            '%(_ReferencedProjectOutputDependency.FrameworkFile)' != 'true' and 
									'%(_ReferencedProjectOutputDependency.ResolvedFrom)' != '{TargetFrameworkDirectory}'">
				<Kind>Lib</Kind>
			</PackageFile>
		</ItemGroup>

		<!-- Main project and dependencies symbols -->
		<MSBuild Projects="@(_NoIsPackableProject)"
				 Condition="'$(IncludeSymbolsInPackage)' == 'true'"
				 Targets="DebugSymbolsProjectOutputGroup"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectDebugSymbols" />
		</MSBuild>

		<ItemGroup>
			<PackageFile Include="@(_ReferencedProjectDebugSymbols -> '%(FinalOutputPath)')">
				<Kind>Symbols</Kind>
			</PackageFile>
		</ItemGroup>

		<MSBuild Projects="@(_NoIsPackableProject)"
				 Condition="'$(IncludeSymbolsInPackage)' == 'true'"
				 Targets="DebugSymbolsProjectOutputGroupDependencies"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectOutputDependencySymbols" />
		</MSBuild>

		<ItemGroup>
			<PackageFile Include="@(_ReferencedProjectOutputDependencySymbols -> '%(FullPath)')"
						 Condition="'%(_ReferencedProjectOutputDependencySymbols.CopyLocal)' == 'true'">
				<Kind>Symbols</Kind>
			</PackageFile>
		</ItemGroup>

		<!-- Main project and dependencies documentation -->
		<MSBuild Projects="@(_NoIsPackableProject)"
				 Targets="DocumentationProjectOutputGroup"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectDocumentation" />
		</MSBuild>

		<ItemGroup>
			<PackageFile Include="@(_ReferencedProjectDocumentation -> '%(FinalOutputPath)')">
				<Kind>Doc</Kind>
			</PackageFile>
		</ItemGroup>

		<MSBuild Projects="@(_NoIsPackableProject)"
				 Targets="DocumentationProjectOutputGroupDependencies"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectDocumentationDependency" />
		</MSBuild>

		<ItemGroup>
			<PackageFile Include="@(_ReferencedProjectDocumentationDependency -> '%(FullPath)')"
						 Condition="'%(_ReferencedProjectDocumentationDependency.CopyLocal)' == 'true'">
				<Kind>Doc</Kind>
			</PackageFile>
		</ItemGroup>

		<!-- Main project and dependencies satellite assemblies -->
		<MSBuild Projects="@(_NoIsPackableProject)"
				 Targets="SatelliteDllsProjectOutputGroup"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectSatelliteDll" />
		</MSBuild>

		<ItemGroup>
			<!-- Change to %(FinalOutputPath) when https://github.com/Microsoft/msbuild/pull/1115 ships -->
			<PackageFile Include="@(_ReferencedProjectSatelliteDll -> '%(FullPath)')">
				<Kind>Lib</Kind>
			</PackageFile>
		</ItemGroup>

		<MSBuild Projects="@(_NoIsPackableProject)"
				 Targets="SatelliteDllsProjectOutputGroupDependencies"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_NoIsPackableProject.SetConfiguration); %(_NoIsPackableProject.SetPlatform)"
				 RemoveProperties="%(_NoIsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectDependencySatelliteDll" />
		</MSBuild>

		<ItemGroup>
			<!-- Change to %(FinalOutputPath) when https://github.com/Microsoft/msbuild/pull/1115 ships -->
			<PackageFile Include="@(_ReferencedProjectDependencySatelliteDll -> '%(FullPath)')"
						 Condition="'%(_ReferencedProjectDependencySatelliteDll.CopyLocal)' == 'true'">
				<Kind>Lib</Kind>
				<TargetPath Condition="'%(_ReferencedProjectDependencySatelliteDll.DestinationSubDirectory)' != ''">%(_ReferencedProjectDependencySatelliteDll.DestinationSubDirectory)%(_ReferencedProjectDependencySatelliteDll.Filename)%(_ReferencedProjectDependencySatelliteDll.Extension)</TargetPath>
			</PackageFile>
		</ItemGroup>

	</Target>
	
	<!-- This is the actual inner target that authors extend when they provide a GetPackageContentsDependsOn target -->
	<Target Name="_CollectAllPackageContents" DependsOnTargets="$(GetPackageContentsDependsOn)" Returns="@(_AllPackageContent)" >
		<!-- PackageId metadata on all PackageFile items means we can tell appart which ones came from which dependencies 
			 NOTE: if PackageId is empty, we won't generate a manifest and it means the files need to be packed with the
			 current project. -->
		<ItemGroup>
			<PackageFile Include="@(BuiltProjectOutputGroupOutput -> '%(FinalOutputPath)')"
                         Condition="'$(IncludeOutputsInPackage)' == 'true'">
				<Kind>Lib</Kind>
			</PackageFile>

			<PackageFile Include="@(DocumentationProjectOutputGroupOutput -> '%(FinalOutputPath)')"
                         Condition="'$(IncludeOutputsInPackage)' == 'true'">
				<Kind>Doc</Kind>
			</PackageFile>

			<PackageFile Include="@(DebugSymbolsProjectOutputGroupOutput -> '%(FinalOutputPath)')"
                         Condition="'$(IncludeOutputsInPackage)' == 'true' and '$(IncludeSymbolsInPackage)' == 'true'">
				<Kind>Symbols</Kind>
			</PackageFile>

			<!-- Change to %(FinalOutputPath) when https://github.com/Microsoft/msbuild/pull/1115 ships -->
			<PackageFile Include="@(SatelliteDllsProjectOutputGroupOutput -> '%(FullPath)')"
						 Condition="'$(IncludeOutputsInPackage)' == 'true'">
				<Kind>Lib</Kind>
			</PackageFile>

			<!-- @ContentFilesProjectOutputGroupOutput = @(ContentWithTargetPath->'%(FullPath)') -->
			<PackageFile Include="@(ContentFilesProjectOutputGroupOutput)"
						 Condition="'$(IncludeContentInPackage)' == 'true'">
				<Kind>Content</Kind>
			</PackageFile>

			<PackageFile Include="@(_NoneWithTargetPath)"
						 Condition="'%(_NoneWithTargetPath.IncludeInPackage)' == 'true'">
				<Kind>None</Kind>
			</PackageFile>

			<PackageFile Include="@(PackageReference)">
				<Kind>Dependency</Kind>
			</PackageFile>

			<!-- We can't use %(FrameworkFile)==true because it's not defined for raw file references and 
			     it also includes mscorlib which we don't need
			     TBD: maybe include ResolvedFrom=ImplicitlyExpandDesignTimeFacades too? -->
			<PackageFile Include="@(ReferencePath->'%(OriginalItemSpec)')"
						 Condition="'$(IncludeFrameworkReferencesInPackage)' == 'true' and '%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}'">
				<Kind>FrameworkReference</Kind>
			</PackageFile>
		</ItemGroup>

		<!-- If packaging the project, provide the metadata as a non-file item -->
		<ItemGroup Condition="'$(PackageId)' != ''">
			<PackageFile Include="@(PackageTargetPath->'%(Id)')">
				<Kind>Metadata</Kind>
			</PackageFile>
		</ItemGroup>

		<ItemGroup>
			<!-- Always annotate files with the declaring project target framework and package id. 
				 TODO: take into account multi-targetting. -->
			<PackageFile>
				<PackageId>$(PackageId)</PackageId>
				<TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
			</PackageFile>
		</ItemGroup>

		<AssignPackagePath Files="@(PackageFile)" Kinds="@(PackageItemKind)">
			<Output TaskParameter="AssignedFiles" ItemName="_AllPackageContent" />
		</AssignPackagePath>

		<ItemGroup>
			<!-- Specific framework targets would turn:
				* @(ReferencePath) with ResolvedFrom={TargetFrameworkDirectory} to Kind=FrameworkReference
				* @(ReferencePath) are resolved otherwise (i.e. ResolvedFrom={RawFile}) to Kind=AssemblyReference
			-->
		</ItemGroup>

		<MSBuild Projects="@(_IsPackableProject)"
				 Targets="GetAllPackageContents"
				 BuildInParallel="$(BuildInParallel)"
				 Properties="%(_IsPackableProject.SetConfiguration); %(_IsPackableProject.SetPlatform)"
				 Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_IsPackableProject)' != ''"
				 RemoveProperties="%(_IsPackableProject.GlobalPropertiesToRemove)">
			<Output TaskParameter="TargetOutputs" ItemName="_ReferencedPackageContent" />
		</MSBuild>

		<!-- Always annotate package contents with the original target framework and moniker -->
		<CreateItem Include="@(_ReferencedPackageContent)" PreserveExistingMetadata="true"
					AdditionalMetadata="OriginalTargetFramework=%(TargetFramework);OriginalTargetFrameworkMoniker=%(TargetFrameworkMoniker)">
			<Output TaskParameter="Include" ItemName="_ReferencedPackageContentWithOriginalValues"/>
		</CreateItem>

		<ItemGroup>
			<!-- Retarget content for the currently building package, if necessary -->
			<_ReferencedPackageContentWithOriginalValues Condition="'%(_ReferencedPackageContentWithOriginalValues.PackageId)' == ''">
				<PackageId>$(PackageId)</PackageId>
				<!-- Clear the target framework since it trumps the TFM in AsignPackagePath now -->
				<!-- Only do this for Library assets that come from project references that don't build nugets (PackageId=='' above) -->
				<TargetFramework Condition="'%(_ReferencedPackageContentWithOriginalValues.Kind)' == 'Lib' or 
											'%(_ReferencedPackageContentWithOriginalValues.Kind)' == 'Library' or 
											'%(_ReferencedPackageContentWithOriginalValues.Kind)' == 'Symbols' or 
											'%(_ReferencedPackageContentWithOriginalValues.Kind)' == 'Doc'"></TargetFramework>
				<!-- NOTE: we're always overwriting the TFM in this case since 
					 this item will end up making up the contents of this package 
					 project in its current TFM configuration. 
					 TBD: we might want to preserve it anyways and adjust later 
					 (i.e. net45 project references netstandard1.6 project)
					 TODO: take into account multi-targetting.
				-->
				<TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
			</_ReferencedPackageContentWithOriginalValues>
		</ItemGroup>

		<!-- Ensure referenced package content gets assigned a package path if it didn't provide one already.
			 This happens for project references' that don't have a PackageId, since their package path will 
			 depend on the referencing project's TFM.
		-->
		<AssignPackagePath Files="@(_ReferencedPackageContentWithOriginalValues)" Kinds="@(PackageItemKind)" Condition="'@(_ReferencedPackageContentWithOriginalValues)' != ''">
			<Output TaskParameter="AssignedFiles" ItemName="_AllPackageContent" />
		</AssignPackagePath>

	</Target>

	<PropertyGroup>
		<_PackDependsOn>
			CoreBuild;
			GetPackageContents;
			_Pack;
		</_PackDependsOn>
	</PropertyGroup>

	<!--
	============================================================
					Pack

    Creates the output .nupkg if the project is packable.
	============================================================
	-->
	<Target Name="Pack" DependsOnTargets="$(_PackDependsOn)" Returns="@(PackageTargetPath)" Condition="'$(IsPackable)' == 'true'" />

	<Target Name="_Pack" DependsOnTargets="$(PackDependsOn)" Returns="@(PackageTargetPath)">
		<ItemGroup>
			<_PackageManifest Include="@(_PackageContent -> WithMetadataValue('Kind', 'Metadata'))" Condition="'%(PackageId)' == '$(PackageId)'" />
		</ItemGroup>
		<!-- RepositoryUrl/RepositoryType/PackageType to be added -->
		<CreatePackage Manifest="@(_PackageManifest)" Contents="@(_PackageContent)" TargetPath="$(PackageTargetPath)">
			<Output TaskParameter="OutputPackage" ItemName="PackageTargetPath" />
		</CreatePackage>

		<Message Importance="high" Text="Created package at $(PackageTargetPath)." />
	</Target>

</Project>
